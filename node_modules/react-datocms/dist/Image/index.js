"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const react_intersection_observer_1 = require("react-intersection-observer");
const imageAddStrategy = ({ lazyLoad, isSsr, isIntersectionObserverAvailable, inView, loaded }) => {
    if (!lazyLoad) {
        return true;
    }
    if (isSsr) {
        return false;
    }
    if (isIntersectionObserverAvailable) {
        return inView || loaded;
    }
    return true;
};
const imageShowStrategy = ({ lazyLoad, isSsr, isIntersectionObserverAvailable, loaded }) => {
    if (!lazyLoad) {
        return true;
    }
    if (isSsr) {
        return false;
    }
    if (isIntersectionObserverAvailable) {
        return loaded;
    }
    return true;
};
exports.Image = function ({ className, fadeInDuration, intersectionTreshold, intersectionMargin, pictureClassName, lazyLoad = true, style, pictureStyle, data }) {
    const [loaded, setLoaded] = react_1.useState(false);
    const handleLoad = react_1.useCallback(() => {
        setLoaded(true);
    }, []);
    const [ref, inView, _entry] = react_intersection_observer_1.useInView({
        threshold: intersectionTreshold || 0,
        rootMargin: intersectionMargin || "0px 0px 0px 0px",
        triggerOnce: true
    });
    const isSsr = typeof window === "undefined";
    const isIntersectionObserverAvailable = isSsr
        ? false
        : !!window.IntersectionObserver;
    const absolutePositioning = {
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%"
    };
    const addImage = imageAddStrategy({ lazyLoad, isSsr, isIntersectionObserverAvailable, inView, loaded });
    const showImage = imageShowStrategy({ lazyLoad, isSsr, isIntersectionObserverAvailable, inView, loaded });
    const webpSource = data.webpSrcSet && (react_1.default.createElement("source", { srcSet: data.webpSrcSet, sizes: data.sizes, type: "image/webp" }));
    const regularSource = data.srcSet && (react_1.default.createElement("source", { srcSet: data.srcSet, sizes: data.sizes }));
    const placeholder = react_1.default.createElement("div", { style: {
            paddingTop: data.width && data.height ? `${data.height / data.width * 100.0}%` : `${100.0 / data.aspectRatio}%`,
            backgroundImage: data.base64 ? `url(${data.base64})` : null,
            backgroundColor: data.bgColor,
            backgroundSize: "cover"
        } });
    return (react_1.default.createElement("div", { ref: ref, className: className, style: Object.assign(Object.assign({ display: "inline-block", maxWidth: "100%", width: `${data.width}px` }, style), { overflow: "hidden", position: "relative" }) },
        placeholder,
        addImage && (react_1.default.createElement("picture", { className: pictureClassName, style: Object.assign(Object.assign(Object.assign({}, pictureStyle), absolutePositioning), { opacity: showImage ? 1 : 0, transition: !fadeInDuration || fadeInDuration > 0
                    ? `opacity ${fadeInDuration || 500}ms`
                    : null }) },
            webpSource,
            regularSource,
            data.src && (react_1.default.createElement("img", { src: data.src, alt: data.alt, title: data.title, onLoad: handleLoad, style: { maxWidth: '100%' } })))),
        react_1.default.createElement("noscript", null,
            react_1.default.createElement("picture", { className: pictureClassName, style: Object.assign(Object.assign({}, pictureStyle), absolutePositioning) },
                webpSource,
                regularSource,
                data.src && react_1.default.createElement("img", { src: data.src, alt: data.alt, title: data.title })))));
};
//# sourceMappingURL=index.js.map